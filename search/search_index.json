{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api_reference/bounding_box/","title":"BoundingBox","text":""},{"location":"api_reference/bounding_box/#aviary.BoundingBox","title":"<code>BoundingBox</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Iterable[Coordinate]</code></p> ATTRIBUTE DESCRIPTION <code>x_min</code> <p>minimum x coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>y_min</code> <p>minimum y coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>x_max</code> <p>maximum x coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>y_max</code> <p>maximum y coordinate</p> <p> TYPE: <code>Coordinate</code> </p> PARAMETER DESCRIPTION <code>x_min</code> <p>minimum x coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>y_min</code> <p>minimum y coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>x_max</code> <p>maximum x coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>y_max</code> <p>maximum y coordinate</p> <p> TYPE: <code>Coordinate</code> </p> RAISES DESCRIPTION <code>AviaryUserError</code> <p>Invalid bounding box (<code>x_min</code> &gt;= <code>x_max</code> or <code>y_min</code> &gt;= <code>y_max</code>)</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.x_min","title":"<code>x_min: Coordinate</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>Coordinate</code> <p>minimum x coordinate</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.y_min","title":"<code>y_min: Coordinate</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>Coordinate</code> <p>minimum y coordinate</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.x_max","title":"<code>x_max: Coordinate</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>Coordinate</code> <p>maximum x coordinate</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.y_max","title":"<code>y_max: Coordinate</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>Coordinate</code> <p>maximum y coordinate</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.from_gdf","title":"<code>from_gdf</code>  <code>classmethod</code>","text":"<p>Creates a bounding box from a geodataframe.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>BoundingBox</code> <p>bounding box</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.__len__","title":"<code>__len__</code>","text":"<p>Computes the number of coordinates.</p> RETURNS DESCRIPTION <code>int</code> <p>number of coordinates</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.__getitem__","title":"<code>__getitem__</code>","text":"<p>Returns the coordinate given the index.</p> PARAMETER DESCRIPTION <code>index</code> <p>index of the coordinate</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Coordinate</code> <p>coordinate</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.__iter__","title":"<code>__iter__</code>","text":"<p>Iterates over the coordinates.</p> YIELDS DESCRIPTION <code>Coordinate</code> <p>coordinate</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.buffer","title":"<code>buffer</code>","text":"<p>Buffers the bounding box.</p> PARAMETER DESCRIPTION <code>buffer_size</code> <p>buffer size in meters</p> <p> TYPE: <code>BufferSize</code> </p> <code>inplace</code> <p>if True, the bounding box is buffered inplace</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>BoundingBox</code> <p>buffered bounding box</p> RAISES DESCRIPTION <code>AviaryUserError</code> <p>Invalid buffer size (abs(<code>buffer_size</code>) &gt;= half the width or height of the bounding box)</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.quantize","title":"<code>quantize</code>","text":"<p>Quantizes the coordinates to the specified value.</p> PARAMETER DESCRIPTION <code>value</code> <p>value to quantize the coordinates to in meters</p> <p> TYPE: <code>int</code> </p> <code>inplace</code> <p>if True, the bounding box is quantized inplace</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>BoundingBox</code> <p>quantized bounding box</p> RAISES DESCRIPTION <code>AviaryUserError</code> <p>Invalid value (<code>value</code> &lt;= 0)</p>"},{"location":"api_reference/bounding_box/#aviary.BoundingBox.to_gdf","title":"<code>to_gdf</code>","text":"<p>Converts the bounding box to a geodataframe.</p> PARAMETER DESCRIPTION <code>epsg_code</code> <p>EPSG code</p> <p> TYPE: <code>EPSGCode</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>bounding box</p>"},{"location":"api_reference/enums/","title":"Enums","text":""},{"location":"api_reference/enums/#aviary.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>Enum</code></p> ATTRIBUTE DESCRIPTION <code>CPU</code> <p>CPU device</p> <p> </p> <code>CUDA</code> <p>CUDA device</p> <p> </p>"},{"location":"api_reference/enums/#aviary.DType","title":"<code>DType</code>","text":"<p>               Bases: <code>Enum</code></p> ATTRIBUTE DESCRIPTION <code>BOOL</code> <p>boolean data type</p> <p> </p> <code>FLOAT32</code> <p>32-bit floating point data type</p> <p> </p> <code>UINT8</code> <p>8-bit unsigned integer data type</p> <p> </p>"},{"location":"api_reference/enums/#aviary.GeospatialFilterMode","title":"<code>GeospatialFilterMode</code>","text":"<p>               Bases: <code>Enum</code></p> ATTRIBUTE DESCRIPTION <code>DIFFERENCE</code> <p>difference mode</p> <p> </p> <code>INTERSECTION</code> <p>intersection mode</p> <p> </p>"},{"location":"api_reference/enums/#aviary.InterpolationMode","title":"<code>InterpolationMode</code>","text":"<p>               Bases: <code>Enum</code></p> ATTRIBUTE DESCRIPTION <code>BILINEAR</code> <p>bilinear mode</p> <p> </p> <code>NEAREST</code> <p>nearest mode</p> <p> </p>"},{"location":"api_reference/enums/#aviary.SegmentationExporterMode","title":"<code>SegmentationExporterMode</code>","text":"<p>               Bases: <code>Enum</code></p> ATTRIBUTE DESCRIPTION <code>FEATHER</code> <p>feather mode</p> <p> </p> <code>GPKG</code> <p>geopackage mode</p> <p> </p>"},{"location":"api_reference/enums/#aviary.SetFilterMode","title":"<code>SetFilterMode</code>","text":"<p>               Bases: <code>Enum</code></p> ATTRIBUTE DESCRIPTION <code>DIFFERENCE</code> <p>difference mode</p> <p> </p> <code>INTERSECTION</code> <p>intersection mode</p> <p> </p> <code>UNION</code> <p>union mode</p> <p> </p>"},{"location":"api_reference/process_area/","title":"ProcessArea","text":""},{"location":"api_reference/process_area/#aviary.ProcessArea","title":"<code>ProcessArea</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Iterable[Coordinates]</code></p> ATTRIBUTE DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>AviaryUserError</code> <p>Invalid coordinates (<code>coordinates</code> is not an array of shape (n, 2) and data type int32)</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.coordinates","title":"<code>coordinates: CoordinatesSet</code>  <code>property</code> <code>writable</code>","text":"RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.from_bounding_box","title":"<code>from_bounding_box</code>  <code>classmethod</code>","text":"<p>Creates a process area from a bounding box.</p> PARAMETER DESCRIPTION <code>bounding_box</code> <p>bounding box</p> <p> TYPE: <code>BoundingBox</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>quantize</code> <p>if True, the bounding box is quantized to <code>tile_size</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>process area</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.from_gdf","title":"<code>from_gdf</code>  <code>classmethod</code>","text":"<p>Creates a process area from a geodataframe.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>quantize</code> <p>if True, the bounding box is quantized to <code>tile_size</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>process area</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.from_json","title":"<code>from_json</code>  <code>classmethod</code>","text":"<p>Creates a process area from a JSON string.</p> PARAMETER DESCRIPTION <code>json_string</code> <p>JSON string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>process area</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates a process area from the configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>ProcessAreaConfig</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>process area</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.__len__","title":"<code>__len__</code>","text":"<p>Computes the number of coordinates.</p> RETURNS DESCRIPTION <code>int</code> <p>number of coordinates</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.__getitem__","title":"<code>__getitem__</code>","text":"<p>Returns the coordinates given the index.</p> PARAMETER DESCRIPTION <code>index</code> <p>index of the coordinates</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Coordinates</code> <p>coordinates</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.__iter__","title":"<code>__iter__</code>","text":"<p>Iterates over the coordinates.</p> YIELDS DESCRIPTION <code>Coordinates</code> <p>coordinates</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.__add__","title":"<code>__add__</code>","text":"<p>Adds the coordinates.</p> Notes <ul> <li>This method is equivalent to applying the set filter with the <code>UNION</code> set filter mode   to the coordinates</li> </ul> PARAMETER DESCRIPTION <code>other</code> <p>other process area</p> <p> TYPE: <code>ProcessArea</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>union of the process areas</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.__sub__","title":"<code>__sub__</code>","text":"<p>Subtracts the coordinates.</p> Notes <ul> <li>This method is equivalent to applying the set filter with the <code>DIFFERENCE</code> set filter mode   to the coordinates</li> </ul> PARAMETER DESCRIPTION <code>other</code> <p>other process area</p> <p> TYPE: <code>ProcessArea</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>difference of the process areas</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.append","title":"<code>append</code>","text":"<p>Appends the coordinates.</p> PARAMETER DESCRIPTION <code>other</code> <p>other coordinates</p> <p> TYPE: <code>Coordinates</code> </p> <code>inplace</code> <p>if True, the coordinates are appended inplace</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>process area</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.chunk","title":"<code>chunk</code>","text":"<p>Chunks the coordinates.</p> PARAMETER DESCRIPTION <code>num_chunks</code> <p>number of chunks</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>list[ProcessArea]</code> <p>list of process areas</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.filter","title":"<code>filter</code>","text":"<p>Filters the coordinates.</p> PARAMETER DESCRIPTION <code>coordinates_filter</code> <p>coordinates filter</p> <p> TYPE: <code>CoordinatesFilter</code> </p> <code>inplace</code> <p>if True, the coordinates are filtered inplace</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>ProcessArea</code> <p>filtered process area</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.to_gdf","title":"<code>to_gdf</code>","text":"<p>Converts the coordinates to a geodataframe.</p> PARAMETER DESCRIPTION <code>epsg_code</code> <p>EPSG code</p> <p> TYPE: <code>EPSGCode</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>geodataframe</p> RAISES DESCRIPTION <code>AviaryUserError</code> <p>Invalid tile size (<code>tile_size</code> &lt;= 0)</p>"},{"location":"api_reference/process_area/#aviary.ProcessArea.to_json","title":"<code>to_json</code>","text":"<p>Converts the coordinates to a JSON string.</p> RETURNS DESCRIPTION <code>str</code> <p>JSON string</p>"},{"location":"api_reference/process_area/#aviary.ProcessAreaConfig","title":"<code>ProcessAreaConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>ProcessArea</code></p> The configuration must have one of the following field sets <ul> <li><code>json_string</code></li> <li><code>gdf</code> and <code>tile_size</code> (optional: <code>quantize</code>)</li> <li><code>bounding_box</code> and <code>tile_size</code> (optional: <code>quantize</code>)</li> </ul> ATTRIBUTE DESCRIPTION <code>bounding_box</code> <p>bounding box</p> <p> TYPE: <code>list[Coordinate] | None</code> </p> <code>gdf</code> <p>path to the geodataframe</p> <p> TYPE: <code>Path | None</code> </p> <code>json_string</code> <p>path to the JSON file</p> <p> TYPE: <code>Path | None</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize | None</code> </p> <code>quantize</code> <p>if True, the bounding box is quantized to <code>tile_size</code></p> <p> TYPE: <code>bool</code> </p>"},{"location":"api_reference/types/","title":"Types","text":""},{"location":"api_reference/types/#aviary._utils.types.BufferSize","title":"<code>BufferSize: TypeAlias = int</code>","text":""},{"location":"api_reference/types/#aviary._utils.types.Coordinate","title":"<code>Coordinate: TypeAlias = int</code>","text":""},{"location":"api_reference/types/#aviary._utils.types.Coordinates","title":"<code>Coordinates: TypeAlias = tuple[Coordinate, Coordinate]</code>","text":""},{"location":"api_reference/types/#aviary._utils.types.CoordinatesSet","title":"<code>CoordinatesSet: TypeAlias = npt.NDArray[np.int32]</code>","text":""},{"location":"api_reference/types/#aviary._utils.types.EPSGCode","title":"<code>EPSGCode: TypeAlias = int</code>","text":""},{"location":"api_reference/types/#aviary._utils.types.GroundSamplingDistance","title":"<code>GroundSamplingDistance: TypeAlias = float</code>","text":""},{"location":"api_reference/types/#aviary._utils.types.TileSize","title":"<code>TileSize: TypeAlias = int</code>","text":""},{"location":"api_reference/data/data_fetcher/","title":"DataFetcher","text":""},{"location":"api_reference/data/data_fetcher/#aviary.data.DataFetcher","title":"<code>DataFetcher</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for data fetchers</p> <p>Data fetchers are callables that fetch data from a source given a minimum x and y coordinate. These coordinates correspond to the bottom left corner of a tile. The data fetcher is used by the dataset to fetch data for each tile.</p> Currently implemented data fetchers <ul> <li>VRTDataFetcher: Fetches data from a virtual raster</li> <li>WMSDataFetcher: Fetches data from a web map service</li> </ul> Notes <ul> <li>Implementations must support concurrency (the data fetcher may be called concurrently by the dataloader)</li> </ul>"},{"location":"api_reference/data/data_fetcher/#aviary.data.DataFetcher.__call__","title":"<code>__call__</code>","text":"<p>Fetches data from the source given a minimum x and y coordinate.</p> PARAMETER DESCRIPTION <code>x_min</code> <p>minimum x coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>y_min</code> <p>minimum y coordinate</p> <p> TYPE: <code>Coordinate</code> </p> RETURNS DESCRIPTION <code>npt.NDArray</code> <p>data</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher","title":"<code>VRTDataFetcher</code>","text":"<p>               Bases: <code>FromConfigMixin</code></p> <p>Data fetcher for virtual rasters</p> <p>Implements the <code>DataFetcher</code> protocol.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to the virtual raster (.vrt file)</p> <p> TYPE: <code>Path</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>ground_sampling_distance</code> <p>ground sampling distance in meters</p> <p> TYPE: <code>GroundSamplingDistance</code> </p> <code>interpolation_mode</code> <p>interpolation mode (<code>BILINEAR</code> or <code>NEAREST</code>)</p> <p> TYPE: <code>InterpolationMode</code> DEFAULT: <code>InterpolationMode.BILINEAR</code> </p> <code>buffer_size</code> <p>buffer size in meters (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>drop_channels</code> <p>channel indices to drop (supports negative indexing)</p> <p> TYPE: <code>list[int]</code> DEFAULT: <code>None</code> </p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.src_bounding_box","title":"<code>src_bounding_box: BoundingBox</code>  <code>property</code>","text":"<p>Bounding box of the virtual raster</p> RETURNS DESCRIPTION <code>BoundingBox</code> <p>bounding box</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.src_dtype","title":"<code>src_dtype: list[DType]</code>  <code>property</code>","text":"<p>Data type of each channel of the virtual raster</p> RETURNS DESCRIPTION <code>list[DType]</code> <p>data type of each channel</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.src_epsg_code","title":"<code>src_epsg_code: EPSGCode</code>  <code>property</code>","text":"<p>EPSG code of the virtual raster</p> RETURNS DESCRIPTION <code>EPSGCode</code> <p>EPSG code</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.src_ground_sampling_distance","title":"<code>src_ground_sampling_distance: GroundSamplingDistance</code>  <code>property</code>","text":"<p>Ground sampling distance of the virtual raster</p> RETURNS DESCRIPTION <code>GroundSamplingDistance</code> <p>ground sampling distance in meters</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.src_num_channels","title":"<code>src_num_channels: int</code>  <code>property</code>","text":"<p>Number of channels of the virtual raster</p> RETURNS DESCRIPTION <code>int</code> <p>number of channels</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>pydantic.BaseModel</code> </p> RETURNS DESCRIPTION <code>FromConfigMixin</code> <p>instance of the class</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcher.__call__","title":"<code>__call__</code>","text":"<p>Fetches data from the virtual raster given a minimum x and y coordinate.</p> PARAMETER DESCRIPTION <code>x_min</code> <p>minimum x coordinate</p> <p> TYPE: <code>Coordinate</code> </p> <code>y_min</code> <p>minimum y coordinate</p> <p> TYPE: <code>Coordinate</code> </p> RETURNS DESCRIPTION <code>npt.NDArray</code> <p>data</p>"},{"location":"api_reference/data/data_fetcher/#aviary.data.VRTDataFetcherConfig","title":"<code>VRTDataFetcherConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>VRTDataFetcher</code></p> ATTRIBUTE DESCRIPTION <code>path</code> <p>path to the virtual raster (.vrt file)</p> <p> TYPE: <code>Path</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>ground_sampling_distance</code> <p>ground sampling distance in meters</p> <p> TYPE: <code>GroundSamplingDistance</code> </p> <code>interpolation_mode</code> <p>interpolation mode ('bilinear' or 'nearest')</p> <p> TYPE: <code>InterpolationMode</code> </p> <code>buffer_size</code> <p>buffer size in meters (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> </p> <code>drop_channels</code> <p>channel indices to drop (supports negative indexing)</p> <p> TYPE: <code>list[int] | None</code> </p>"},{"location":"api_reference/data/data_preprocessor/","title":"DataPreprocessor","text":""},{"location":"api_reference/data/data_preprocessor/#aviary.data.DataPreprocessor","title":"<code>DataPreprocessor</code>","text":"<p>               Bases: <code>ABC</code>, <code>FromConfigMixin</code></p> <p>Abstract class for data preprocessors</p> <p>Data preprocessors are callables that preprocess data. The data preprocessor is used by the dataset to preprocess the fetched data for each tile.</p> Currently implemented data preprocessors <ul> <li>CompositePreprocessor: Composes multiple data preprocessors</li> <li>NormalizePreprocessor: Applies min-max normalization</li> <li>StandardizePreprocessor: Applies standardization</li> <li>ToTensorPreprocessor: Converts the data to a tensor</li> </ul>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.DataPreprocessor.__call__","title":"<code>__call__</code>  <code>abstractmethod</code>","text":"<p>Preprocesses the data.</p> PARAMETER DESCRIPTION <code>data</code> <p>data</p> <p> TYPE: <code>npt.NDArray | torch.Tensor</code> </p> RETURNS DESCRIPTION <code>npt.NDArray | torch.Tensor</code> <p>preprocessed data</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.CompositePreprocessor","title":"<code>CompositePreprocessor</code>","text":"<p>               Bases: <code>DataPreprocessor</code></p> <p>Data preprocessor that composes multiple data preprocessors</p> PARAMETER DESCRIPTION <code>data_preprocessors</code> <p>data preprocessors</p> <p> TYPE: <code>list[DataPreprocessor]</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.CompositePreprocessor.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates a composite preprocessor from the configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>CompositePreprocessorConfig</code> </p> RETURNS DESCRIPTION <code>CompositePreprocessor</code> <p>composite preprocessor</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.CompositePreprocessor.__call__","title":"<code>__call__</code>","text":"<p>Preprocesses the data with each data preprocessor.</p> PARAMETER DESCRIPTION <code>data</code> <p>data</p> <p> TYPE: <code>npt.NDArray</code> </p> RETURNS DESCRIPTION <code>npt.NDArray | torch.Tensor</code> <p>preprocessed data</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.CompositePreprocessorConfig","title":"<code>CompositePreprocessorConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>CompositePreprocessor</code></p> ATTRIBUTE DESCRIPTION <code>data_preprocessors_configs</code> <p>configurations of the data preprocessors</p> <p> TYPE: <code>list[DataPreprocessorConfig]</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.DataPreprocessorConfig","title":"<code>DataPreprocessorConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for data preprocessors</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>name of the data preprocessor</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>configuration of the data preprocessor</p> <p> TYPE: <code>NormalizePreprocessorConfig | StandardizePreprocessorConfig | ToTensorPreprocessorConfig</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.NormalizePreprocessor","title":"<code>NormalizePreprocessor</code>","text":"<p>               Bases: <code>DataPreprocessor</code></p> <p>Data preprocessor that applies min-max normalization</p> <p>Examples:</p> <p>Assume the data is a 3-channel image of data type uint8.</p> <pre><code>&gt;&gt;&gt; min_values = [0.] * 3\n&gt;&gt;&gt; max_values = [255.] * 3\n&gt;&gt;&gt; normalize_preprocessor = NormalizePreprocessor(\n...     min_values=min_values,\n...     max_values=max_values,\n... )\n&gt;&gt;&gt; preprocessed_data = normalize_preprocessor(data)\n</code></pre> PARAMETER DESCRIPTION <code>min_values</code> <p>minimum values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p> <code>max_values</code> <p>maximum values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.NormalizePreprocessor.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>pydantic.BaseModel</code> </p> RETURNS DESCRIPTION <code>FromConfigMixin</code> <p>instance of the class</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.NormalizePreprocessor.__call__","title":"<code>__call__</code>","text":"<p>Preprocesses the data by applying min-max normalization.</p> PARAMETER DESCRIPTION <code>data</code> <p>data</p> <p> TYPE: <code>npt.NDArray</code> </p> RETURNS DESCRIPTION <code>npt.NDArray[np.float32]</code> <p>preprocessed data</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.NormalizePreprocessorConfig","title":"<code>NormalizePreprocessorConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>NormalizePreprocessor</code></p> ATTRIBUTE DESCRIPTION <code>min_values</code> <p>minimum values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p> <code>max_values</code> <p>maximum values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.StandardizePreprocessor","title":"<code>StandardizePreprocessor</code>","text":"<p>               Bases: <code>DataPreprocessor</code></p> <p>Data preprocessor that applies standardization</p> <p>Examples:</p> <p>Assume the data is a 3-channel image of data type float32. In this example the mean and standard deviation values from the ImageNet dataset are used.</p> <pre><code>&gt;&gt;&gt; mean_values = [.485, .456, .406]\n&gt;&gt;&gt; std_values = [.229, .224, .225]\n&gt;&gt;&gt; standardize_preprocessor = StandardizePreprocessor(\n...     mean_values=mean_values,\n...     std_values=std_values,\n... )\n&gt;&gt;&gt; preprocessed_data = standardize_preprocessor(data)\n</code></pre> PARAMETER DESCRIPTION <code>mean_values</code> <p>mean values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p> <code>std_values</code> <p>standard deviation values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.StandardizePreprocessor.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>pydantic.BaseModel</code> </p> RETURNS DESCRIPTION <code>FromConfigMixin</code> <p>instance of the class</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.StandardizePreprocessor.__call__","title":"<code>__call__</code>","text":"<p>Preprocesses the data by applying standardization.</p> PARAMETER DESCRIPTION <code>data</code> <p>data</p> <p> TYPE: <code>npt.NDArray</code> </p> RETURNS DESCRIPTION <code>npt.NDArray[np.float32]</code> <p>preprocessed data</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.StandardizePreprocessorConfig","title":"<code>StandardizePreprocessorConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>StandardizePreprocessor</code></p> ATTRIBUTE DESCRIPTION <code>mean_values</code> <p>mean values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p> <code>std_values</code> <p>standard deviation values of the data (per channel)</p> <p> TYPE: <code>list[float]</code> </p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.ToTensorPreprocessor","title":"<code>ToTensorPreprocessor</code>","text":"<p>               Bases: <code>DataPreprocessor</code></p> <p>Data preprocessor that converts the data to a tensor</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.ToTensorPreprocessor.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>pydantic.BaseModel</code> </p> RETURNS DESCRIPTION <code>FromConfigMixin</code> <p>instance of the class</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.ToTensorPreprocessor.__call__","title":"<code>__call__</code>","text":"<p>Converts the data to a tensor.</p> PARAMETER DESCRIPTION <code>data</code> <p>data</p> <p> TYPE: <code>npt.NDArray[np.float32]</code> </p> RETURNS DESCRIPTION <code>torch.Tensor</code> <p>tensor</p>"},{"location":"api_reference/data/data_preprocessor/#aviary.data.ToTensorPreprocessorConfig","title":"<code>ToTensorPreprocessorConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>ToTensorPreprocessor</code></p>"},{"location":"api_reference/data/dataset/","title":"Dataset","text":""},{"location":"api_reference/data/dataset/#aviary.data.Dataset","title":"<code>Dataset</code>","text":"<p>               Bases: <code>torch.utils.data.Dataset</code></p> <p>Dataset</p> <p>A dataset is an iterable that returns data for each tile by calling the data fetcher and data preprocessor. The dataset is used by the dataloader to fetch and preprocess data for each batch.</p> PARAMETER DESCRIPTION <code>data_fetcher</code> <p>data fetcher</p> <p> TYPE: <code>DataFetcher</code> </p> <code>data_preprocessor</code> <p>data preprocessor</p> <p> TYPE: <code>DataPreprocessor</code> </p> <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p>"},{"location":"api_reference/data/dataset/#aviary.data.Dataset.__len__","title":"<code>__len__</code>","text":"<p>Computes the number of tiles.</p> RETURNS DESCRIPTION <code>int</code> <p>number of tiles</p>"},{"location":"api_reference/data/dataset/#aviary.data.Dataset.__getitem__","title":"<code>__getitem__</code>","text":"<p>Fetches and preprocesses data given the index of the tile.</p> PARAMETER DESCRIPTION <code>index</code> <p>index of the tile</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple[npt.NDArray | torch.Tensor, Coordinate, Coordinate]</code> <p>data and coordinates (x_min, y_min) of the tile</p>"},{"location":"api_reference/geodata/coordinates_filter/","title":"CoordinatesFilter","text":""},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.CoordinatesFilter","title":"<code>CoordinatesFilter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for coordinates filters</p> <p>Coordinates filters are callables that filter coordinates. The coordinates filter can be used to filter the coordinates of the bottom left corner of each tile. E.g., to remove tiles that do not intersect with an area of interest or tiles that are already processed.</p> Currently implemented coordinates filters <ul> <li>CompositeFilter: Composes multiple coordinates filters</li> <li>DuplicatesFilter: Removes duplicates</li> <li>GeospatialFilter: Filters based on geospatial data</li> <li>MaskFilter: Filters based on a boolean mask</li> <li>SetFilter: Filters based on other coordinates</li> </ul>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.CoordinatesFilter.__call__","title":"<code>__call__</code>  <code>abstractmethod</code>","text":"<p>Filters the coordinates.</p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>filtered coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.CompositeFilter","title":"<code>CompositeFilter</code>","text":"<p>               Bases: <code>CoordinatesFilter</code></p> <p>Coordinates filter that composes multiple coordinates filters</p> PARAMETER DESCRIPTION <code>coordinates_filters</code> <p>coordinates filters</p> <p> TYPE: <code>list[CoordinatesFilter]</code> </p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.CompositeFilter.__call__","title":"<code>__call__</code>","text":"<p>Filters the coordinates with each coordinates filter.</p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>filtered coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.DuplicatesFilter","title":"<code>DuplicatesFilter</code>","text":"<p>               Bases: <code>CoordinatesFilter</code></p> <p>Coordinates filter that removes duplicates</p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.DuplicatesFilter.__call__","title":"<code>__call__</code>","text":"<p>Filters the coordinates by removing duplicates.</p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>filtered coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.GeospatialFilter","title":"<code>GeospatialFilter</code>","text":"<p>               Bases: <code>CoordinatesFilter</code></p> <p>Coordinates filter that filters based on geospatial data</p> Available modes <ul> <li><code>DIFFERENCE</code>: Removes coordinates of tiles that are within the polygons in the geodataframe</li> <li><code>INTERSECTION</code>: Removes coordinates of tiles that do not intersect with the polygons in the geodataframe</li> </ul> PARAMETER DESCRIPTION <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> <code>mode</code> <p>geospatial filter mode (<code>DIFFERENCE</code> or <code>INTERSECTION</code>)</p> <p> TYPE: <code>GeospatialFilterMode</code> </p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.GeospatialFilter.__call__","title":"<code>__call__</code>","text":"<p>Filters the coordinates based on the polygons in the geodataframe.</p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>filtered coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.MaskFilter","title":"<code>MaskFilter</code>","text":"<p>               Bases: <code>CoordinatesFilter</code></p> <p>Coordinates filter that filters based on a boolean mask</p> PARAMETER DESCRIPTION <code>mask</code> <p>boolean mask</p> <p> TYPE: <code>npt.NDArray[np.bool_]</code> </p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.MaskFilter.__call__","title":"<code>__call__</code>","text":"<p>Filters the coordinates based on the boolean mask.</p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>filtered coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.SetFilter","title":"<code>SetFilter</code>","text":"<p>               Bases: <code>CoordinatesFilter</code></p> <p>Coordinates filter that filters based on other coordinates</p> Available modes <ul> <li><code>DIFFERENCE</code>: Removes coordinates that are in the other coordinates</li> <li><code>INTERSECTION</code>: Removes coordinates that are not in the other coordinates</li> <li><code>UNION</code>: Combines the coordinates with the other coordinates and removes duplicates</li> </ul> PARAMETER DESCRIPTION <code>other</code> <p>other coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> <code>mode</code> <p>set filter mode (<code>DIFFERENCE</code>, <code>INTERSECTION</code> or <code>UNION</code>)</p> <p> TYPE: <code>SetFilterMode</code> </p>"},{"location":"api_reference/geodata/coordinates_filter/#aviary.geodata.SetFilter.__call__","title":"<code>__call__</code>","text":"<p>Filters the coordinates based on the other coordinates.</p> PARAMETER DESCRIPTION <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>filtered coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/geodata_postprocessor/","title":"GeodataPostprocessor","text":""},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.GeodataPostprocessor","title":"<code>GeodataPostprocessor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for geodata postprocessors</p> <p>Geodata postprocessors are callables that postprocess geodata. The geodata postprocessor is used by the pipeline to postprocess the resulting geodata, which is the vectorized output of the model's inference.</p> Currently implemented geodata postprocessors <ul> <li>ClipPostprocessor: Clips the polygons based on the mask extent</li> <li>CompositePostprocessor: Composes multiple geodata postprocessors</li> <li>FieldNamePostprocessor: Renames the fields</li> <li>FillPostprocessor: Fills holes in the polygons</li> <li>SievePostprocessor: Sieves the polygons</li> <li>SimplifyPostprocessor: Simplifies the polygons by applying the Douglas-Peucker algorithm</li> <li>ValuePostprocessor: Maps the values of a field</li> </ul>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.GeodataPostprocessor.__call__","title":"<code>__call__</code>  <code>abstractmethod</code>","text":"<p>Postprocesses the geodata.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.ClipPostprocessor","title":"<code>ClipPostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that clips the polygons based on the mask extent</p> PARAMETER DESCRIPTION <code>mask</code> <p>geodataframe of the mask (may contain multiple polygons)</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.ClipPostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata by clipping the polygons based on the mask extent.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.CompositePostprocessor","title":"<code>CompositePostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that composes multiple geodata postprocessors</p> PARAMETER DESCRIPTION <code>geodata_postprocessors</code> <p>geodata postprocessors</p> <p> TYPE: <code>list[GeodataPostprocessor]</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.CompositePostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata with each geodata postprocessor.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.FieldNamePostprocessor","title":"<code>FieldNamePostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that renames the fields</p> PARAMETER DESCRIPTION <code>mapping</code> <p>mapping of the field names (old field name: new field name)</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.FieldNamePostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata by renaming the fields.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.FillPostprocessor","title":"<code>FillPostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that fills holes in the polygons</p> PARAMETER DESCRIPTION <code>max_area</code> <p>maximum area of the holes to retain in square meters</p> <p> TYPE: <code>float</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.FillPostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata by filling holes in the polygons.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.SievePostprocessor","title":"<code>SievePostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that sieves the polygons</p> PARAMETER DESCRIPTION <code>min_area</code> <p>minimum area of the polygons to retain in square meters</p> <p> TYPE: <code>float</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.SievePostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata by sieving the polygons.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.SimplifyPostprocessor","title":"<code>SimplifyPostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that simplifies the polygons by applying the Douglas-Peucker algorithm</p> PARAMETER DESCRIPTION <code>tolerance</code> <p>tolerance of the Douglas-Peucker algorithm in meters (a lower value will result in less simplification, a higher value will result in more simplification, a value equal to the ground sampling distance is recommended)</p> <p> TYPE: <code>float</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.SimplifyPostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata by simplifying the polygons.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.ValuePostprocessor","title":"<code>ValuePostprocessor</code>","text":"<p>               Bases: <code>GeodataPostprocessor</code></p> <p>Geodata postprocessor that maps the values of a field</p> PARAMETER DESCRIPTION <code>mapping</code> <p>mapping of the values (old value: new value)</p> <p> TYPE: <code>dict</code> </p> <code>field_name</code> <p>name of the field</p> <p> TYPE: <code>str</code> DEFAULT: <code>'class'</code> </p>"},{"location":"api_reference/geodata/geodata_postprocessor/#aviary.geodata.ValuePostprocessor.__call__","title":"<code>__call__</code>","text":"<p>Postprocesses the geodata by mapping the values of a field.</p> PARAMETER DESCRIPTION <code>gdf</code> <p>geodataframe</p> <p> TYPE: <code>gpd.GeoDataFrame</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>postprocessed geodataframe</p>"},{"location":"api_reference/geodata/grid_generator/","title":"GridGenerator","text":""},{"location":"api_reference/geodata/grid_generator/#aviary.geodata.GridGenerator","title":"<code>GridGenerator</code>","text":"<p>Grid generator</p> <p>A grid generator generates a grid of tiles. The grid generator can be used to compute the coordinates of the bottom left corner of each tile or to generate a geodataframe of the grid for aggregation.</p> PARAMETER DESCRIPTION <code>bounding_box</code> <p>bounding box</p> <p> TYPE: <code>BoundingBox</code> </p> <code>epsg_code</code> <p>EPSG code</p> <p> TYPE: <code>EPSGCode</code> </p>"},{"location":"api_reference/geodata/grid_generator/#aviary.geodata.GridGenerator.compute_coordinates","title":"<code>compute_coordinates</code>","text":"<p>Computes the coordinates of the bottom left corner of each tile.</p> PARAMETER DESCRIPTION <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>quantize</code> <p>if True, the bounding box is quantized to <code>tile_size</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>CoordinatesSet</code> <p>coordinates (x_min, y_min) of each tile</p>"},{"location":"api_reference/geodata/grid_generator/#aviary.geodata.GridGenerator.generate_grid","title":"<code>generate_grid</code>","text":"<p>Generates a geodataframe of the grid.</p> PARAMETER DESCRIPTION <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>quantize</code> <p>if True, the bounding box is quantized to <code>tile_size</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>gpd.GeoDataFrame</code> <p>grid</p>"},{"location":"api_reference/inference/exporter/","title":"Exporter","text":""},{"location":"api_reference/inference/exporter/#aviary.inference.Exporter","title":"<code>Exporter</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for exporters</p> <p>Exporters are callables that export predictions. The exporter is used by the pipeline to export the batched output of the model's inference.</p> Currently implemented exporters <ul> <li>SegmentationExporter: Exports segmentation predictions</li> </ul>"},{"location":"api_reference/inference/exporter/#aviary.inference.Exporter.__call__","title":"<code>__call__</code>","text":"<p>Exports the predictions.</p> PARAMETER DESCRIPTION <code>preds</code> <p>batched predictions</p> <p> TYPE: <code>npt.NDArray[np.uint8]</code> </p> <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p>"},{"location":"api_reference/inference/exporter/#aviary.inference.SegmentationExporter","title":"<code>SegmentationExporter</code>","text":"<p>               Bases: <code>FromConfigMixin</code></p> <p>Exporter for segmentation predictions</p> <p>Implements the <code>Exporter</code> protocol.</p> <p>The predictions (i.e. raster data) are transformed to geospatial data (i.e. vector data). The resulting geodataframe contains the geometry of the polygons and their class that is stored in the field <code>field_name</code> as the pixel value of the prediction. The coordinates of the processed tiles are exported dynamically to a JSON file named <code>processed_coordinates.json</code>.</p> Available modes <ul> <li><code>FEATHER</code>: For each processed tile, the segmentation exporter creates a subdirectory named <code>{x_min}_{y_min}</code>   (if the tile contains any polygons, it exports the geodataframe as a feather file   named <code>{x_min}_{y_min}.feather</code>)</li> <li><code>GPKG</code>: The segmentation exporter creates a geopackage named <code>output.gpkg</code></li> </ul> PARAMETER DESCRIPTION <code>path</code> <p>path to the output directory</p> <p> TYPE: <code>Path</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>ground_sampling_distance</code> <p>ground sampling distance in meters</p> <p> TYPE: <code>GroundSamplingDistance</code> </p> <code>epsg_code</code> <p>EPSG code</p> <p> TYPE: <code>EPSGCode</code> </p> <code>field_name</code> <p>name of the field in the geodataframe</p> <p> TYPE: <code>str</code> DEFAULT: <code>'class'</code> </p> <code>mode</code> <p>segmentation exporter mode (<code>FEATHER</code> or <code>GPKG</code>)</p> <p> TYPE: <code>SegmentationExporterMode</code> DEFAULT: <code>SegmentationExporterMode.GPKG</code> </p> <code>num_workers</code> <p>number of workers</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"api_reference/inference/exporter/#aviary.inference.SegmentationExporter.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates an instance of the class from a configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>pydantic.BaseModel</code> </p> RETURNS DESCRIPTION <code>FromConfigMixin</code> <p>instance of the class</p>"},{"location":"api_reference/inference/exporter/#aviary.inference.SegmentationExporter.__call__","title":"<code>__call__</code>","text":"<p>Exports the predictions.</p> PARAMETER DESCRIPTION <code>preds</code> <p>batched predictions</p> <p> TYPE: <code>npt.NDArray[np.uint8]</code> </p> <code>coordinates</code> <p>coordinates (x_min, y_min) of each tile</p> <p> TYPE: <code>CoordinatesSet</code> </p>"},{"location":"api_reference/inference/exporter/#aviary.inference.SegmentationExporterConfig","title":"<code>SegmentationExporterConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>SegmentationExporter</code></p> ATTRIBUTE DESCRIPTION <code>path</code> <p>path to the output directory</p> <p> TYPE: <code>Path</code> </p> <code>tile_size</code> <p>tile size in meters</p> <p> TYPE: <code>TileSize</code> </p> <code>ground_sampling_distance</code> <p>ground sampling distance in meters</p> <p> TYPE: <code>GroundSamplingDistance</code> </p> <code>epsg_code</code> <p>EPSG code</p> <p> TYPE: <code>EPSGCode</code> </p> <code>field_name</code> <p>name of the field in the geodataframe</p> <p> TYPE: <code>str</code> </p> <code>mode</code> <p>segmentation exporter mode ('feather' or 'gpkg')</p> <p> TYPE: <code>SegmentationExporterMode</code> </p> <code>num_workers</code> <p>number of workers</p> <p> TYPE: <code>int</code> </p>"},{"location":"api_reference/inference/model/","title":"Model","text":""},{"location":"api_reference/inference/model/#aviary.inference.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for models</p> Currently implemented models <ul> <li>ONNXSegmentationModel: ONNX model for segmentation</li> </ul>"},{"location":"api_reference/inference/model/#aviary.inference.Model.__call__","title":"<code>__call__</code>","text":"<p>Runs the model.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>batched inputs</p> <p> TYPE: <code>npt.NDArray | torch.Tensor</code> </p> RETURNS DESCRIPTION <code>npt.NDArray</code> <p>batched predictions</p>"},{"location":"api_reference/inference/model/#aviary.inference.SegmentationModel","title":"<code>SegmentationModel</code>","text":"<p>Model for segmentation</p> PARAMETER DESCRIPTION <code>path</code> <p>path to the model</p> <p> TYPE: <code>Path</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>device</code> <p>device (<code>CPU</code> or <code>CUDA</code>)</p> <p> TYPE: <code>Device</code> DEFAULT: <code>Device.CPU</code> </p>"},{"location":"api_reference/inference/model/#aviary.inference.SegmentationModel.from_huggingface","title":"<code>from_huggingface</code>  <code>classmethod</code>","text":"<p>Creates a segmentation model from the Hugging Face Hub.</p> PARAMETER DESCRIPTION <code>repo</code> <p>repository (Hugging Face Hub, e.g. 'user/repo')</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>path to the model (Hugging Face Hub)</p> <p> TYPE: <code>str</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>device</code> <p>device (<code>CPU</code> or <code>CUDA</code>)</p> <p> TYPE: <code>Device</code> DEFAULT: <code>Device.CPU</code> </p> RETURNS DESCRIPTION <code>SegmentationModel</code> <p>segmentation model</p>"},{"location":"api_reference/inference/model/#aviary.inference.SegmentationModel.from_aviary","title":"<code>from_aviary</code>  <code>classmethod</code>","text":"<p>Creates a segmentation model from the name of a model in aviary.</p> PARAMETER DESCRIPTION <code>name</code> <p>name of the model</p> <p> TYPE: <code>str</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>device</code> <p>device (<code>CPU</code> or <code>CUDA</code>)</p> <p> TYPE: <code>Device</code> DEFAULT: <code>Device.CPU</code> </p> RETURNS DESCRIPTION <code>SegmentationModel</code> <p>segmentation model</p>"},{"location":"api_reference/inference/model/#aviary.inference.SegmentationModel.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates a segmentation model from the configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>SegmentationModelConfig</code> </p> RETURNS DESCRIPTION <code>SegmentationModel</code> <p>segmentation model</p>"},{"location":"api_reference/inference/model/#aviary.inference.SegmentationModel.__call__","title":"<code>__call__</code>","text":"<p>Runs the model.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>batched inputs</p> <p> TYPE: <code>npt.NDArray | torch.Tensor</code> </p> RETURNS DESCRIPTION <code>npt.NDArray</code> <p>batched predictions</p>"},{"location":"api_reference/inference/model/#aviary.inference.SegmentationModelConfig","title":"<code>SegmentationModelConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>SegmentationModel</code></p> The configuration must have one of the following field sets <ul> <li><code>name</code></li> <li><code>repo</code> and <code>path</code></li> <li><code>path</code></li> </ul> ATTRIBUTE DESCRIPTION <code>path</code> <p>path to the model (local or Hugging Face Hub)</p> <p> TYPE: <code>Path | None</code> </p> <code>repo</code> <p>repository (Hugging Face Hub, e.g. 'user/repo')</p> <p> TYPE: <code>str | None</code> </p> <code>name</code> <p>name of the model</p> <p> TYPE: <code>str | None</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> </p> <code>device</code> <p>device ('cpu' or 'cuda')</p> <p> TYPE: <code>Device</code> </p>"},{"location":"api_reference/inference/model/#aviary.inference.ONNXSegmentationModel","title":"<code>ONNXSegmentationModel</code>","text":"<p>               Bases: <code>SegmentationModel</code></p> <p>ONNX model for segmentation</p> <p>Implements the <code>Model</code> protocol.</p> PARAMETER DESCRIPTION <code>path</code> <p>path to the model</p> <p> TYPE: <code>Path</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>device</code> <p>device (<code>CPU</code> or <code>CUDA</code>)</p> <p> TYPE: <code>Device</code> DEFAULT: <code>Device.CPU</code> </p>"},{"location":"api_reference/inference/model/#aviary.inference.ONNXSegmentationModel.from_huggingface","title":"<code>from_huggingface</code>  <code>classmethod</code>","text":"<p>Creates a segmentation model from the Hugging Face Hub.</p> PARAMETER DESCRIPTION <code>repo</code> <p>repository (Hugging Face Hub, e.g. 'user/repo')</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>path to the model (Hugging Face Hub)</p> <p> TYPE: <code>str</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>device</code> <p>device (<code>CPU</code> or <code>CUDA</code>)</p> <p> TYPE: <code>Device</code> DEFAULT: <code>Device.CPU</code> </p> RETURNS DESCRIPTION <code>SegmentationModel</code> <p>segmentation model</p>"},{"location":"api_reference/inference/model/#aviary.inference.ONNXSegmentationModel.from_aviary","title":"<code>from_aviary</code>  <code>classmethod</code>","text":"<p>Creates a segmentation model from the name of a model in aviary.</p> PARAMETER DESCRIPTION <code>name</code> <p>name of the model</p> <p> TYPE: <code>str</code> </p> <code>buffer_size</code> <p>buffer size in pixels (specifies the area around the tile that is additionally fetched)</p> <p> TYPE: <code>BufferSize</code> DEFAULT: <code>0</code> </p> <code>device</code> <p>device (<code>CPU</code> or <code>CUDA</code>)</p> <p> TYPE: <code>Device</code> DEFAULT: <code>Device.CPU</code> </p> RETURNS DESCRIPTION <code>SegmentationModel</code> <p>segmentation model</p>"},{"location":"api_reference/inference/model/#aviary.inference.ONNXSegmentationModel.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates a segmentation model from the configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>SegmentationModelConfig</code> </p> RETURNS DESCRIPTION <code>SegmentationModel</code> <p>segmentation model</p>"},{"location":"api_reference/inference/model/#aviary.inference.ONNXSegmentationModel.__call__","title":"<code>__call__</code>","text":"<p>Runs the model.</p> PARAMETER DESCRIPTION <code>inputs</code> <p>batched inputs</p> <p> TYPE: <code>npt.NDArray</code> </p> RETURNS DESCRIPTION <code>npt.NDArray</code> <p>batched predictions</p>"},{"location":"api_reference/pipeline/segmentation_pipeline/","title":"SegmentationPipeline","text":""},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.SegmentationPipeline","title":"<code>SegmentationPipeline</code>","text":"<p>Pre-built segmentation pipeline</p> PARAMETER DESCRIPTION <code>data_fetcher</code> <p>data fetcher</p> <p> TYPE: <code>DataFetcher</code> </p> <code>data_preprocessor</code> <p>data preprocessor</p> <p> TYPE: <code>DataPreprocessor</code> </p> <code>process_area</code> <p>process area</p> <p> TYPE: <code>ProcessArea</code> </p> <code>model</code> <p>model</p> <p> TYPE: <code>SegmentationModel</code> </p> <code>exporter</code> <p>exporter</p> <p> TYPE: <code>SegmentationExporter</code> </p> <code>batch_size</code> <p>batch size</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>num_workers</code> <p>number of workers</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.SegmentationPipeline.from_config","title":"<code>from_config</code>  <code>classmethod</code>","text":"<p>Creates a segmentation pipeline from the configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration</p> <p> TYPE: <code>SegmentationPipelineConfig</code> </p> RETURNS DESCRIPTION <code>SegmentationPipeline</code> <p>segmentation pipeline</p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.SegmentationPipeline.__call__","title":"<code>__call__</code>","text":"<p>Runs the segmentation pipeline.</p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.SegmentationPipelineConfig","title":"<code>SegmentationPipelineConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for the <code>from_config</code> classmethod of <code>SegmentationPipeline</code></p> ATTRIBUTE DESCRIPTION <code>data_fetcher_config</code> <p>configuration of the data fetcher</p> <p> TYPE: <code>DataFetcherConfig</code> </p> <code>data_preprocessor_config</code> <p>configuration of the data preprocessor</p> <p> TYPE: <code>DataPreprocessorConfig</code> </p> <code>process_area_config</code> <p>configuration of the process area</p> <p> TYPE: <code>ProcessAreaConfig</code> </p> <code>segmentation_model_config</code> <p>configuration of the model</p> <p> TYPE: <code>ModelConfig</code> </p> <code>exporter_config</code> <p>configuration of the exporter</p> <p> TYPE: <code>ExporterConfig</code> </p> <code>batch_size</code> <p>batch size</p> <p> TYPE: <code>int</code> </p> <code>num_workers</code> <p>number of workers</p> <p> TYPE: <code>int</code> </p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.DataFetcherConfig","title":"<code>DataFetcherConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for data fetchers</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>name of the data fetcher</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>configuration of the data fetcher</p> <p> TYPE: <code>VRTDataFetcherConfig</code> </p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.DataPreprocessorConfig","title":"<code>DataPreprocessorConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for data preprocessors</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>name of the data preprocessor</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>configuration of the data preprocessor</p> <p> TYPE: <code>CompositePreprocessorConfig | NormalizePreprocessorConfig | StandardizePreprocessorConfig | ToTensorPreprocessorConfig</code> </p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.ModelConfig","title":"<code>ModelConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for models</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>name of the model</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>configuration of the model</p> <p> TYPE: <code>SegmentationModelConfig</code> </p>"},{"location":"api_reference/pipeline/segmentation_pipeline/#aviary.pipeline.ExporterConfig","title":"<code>ExporterConfig</code>","text":"<p>               Bases: <code>pydantic.BaseModel</code></p> <p>Configuration for exporters</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>name of the exporter</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>configuration of the exporter</p> <p> TYPE: <code>SegmentationExporterConfig</code> </p>"}]}